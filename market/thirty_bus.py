import numpy as np
from cvxopt import matrix, solvers
solvers.options['show_progress'] = False


# 市场出清，考虑网络阻塞
def market_clearing(a_declare):

    # 供给曲线的截距和斜率
    a_real = np.array([18.0, 20.0, 25.0, 22.0, 22.0, 16.0])
    b_real = np.array([0.25, 0.20, 0.20, 0.20, 0.20, 0.25])

    # 需求曲线的截距和斜率
    c_real = np.array([120.0, 130.0, 120.0, 135.0, 150.0, 95.0, 150.0, 125.0, 100.0, 150.0,
                       90.0, 95.0, 90.0, 90.0, 160.0, 120.0, 150.0, 100.0, 95.0, 125.0]) * -1
    d_real = np.array([5.0, 5.5, 4.5, 5.0, 5.0, 3.0, 5.5, 4.0, 4.5, 5.0,
                       3.5, 3.5, 3.5, 3.5, 6.0, 5.0, 6.0, 4.5, 3.5, 4.5])

    # 机组功率上下限
    p_min = np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0])
    p_max = np.array([100.0, 80.0, 50.0, 80.0, 50.0, 120.0])

    # 负荷需求上下限
    q_min = np.zeros(20)
    q_max = np.array([24.0, 23.63636364, 26.66666667, 27.0, 30.0,
                      31.66666667, 27.27272727, 31.25, 22.22222222, 30.0,
                      25.71428571, 27.14285714, 25.71428571, 25.71428571, 26.66666667,
                      24.0, 25.0, 22.22222222, 27.14285714, 27.77777778])

    J_g = ([[-0.6616, -0.3384, -0.2243, -0.3384, -0.1357, -0.3016, -0.4039, -0.1357, 0.1357, -0.1287, -0.1260, -0.0720, 0.0000, -0.1260, -0.1588, 0.0000, -0.0279, -0.0986, -0.0323, -0.0279, -0.0323, -0.0038, -0.0038, -0.0038, 0.0038, 0.0323, -0.1463, -0.0878, -0.1463, -0.1227, -0.2340, -0.1227, -0.3567, 0.0000, -0.3567, -0.6433, -0.4082, -0.5918, -0.4082, -0.1287, -0.5146],
            [0.1775, -0.1775, -0.3028, -0.1775, -0.1613, -0.3585, -0.3263, -0.1613, 0.1613, -0.1288, -0.1285, -0.0734, 0.0000, -0.1285, -0.1539, 0.0000, -0.0273, -0.0965, -0.0301, -0.0273, -0.0301, -0.0025, -0.0025, -0.0025, 0.0025, 0.0301, -0.1466, -0.0879, -0.1466, -0.1213, -0.2345, -0.1213, -0.3558, 0.0000, -0.3558, -0.6442, -0.4082, -0.5918, -0.4082, -0.1288, -0.5154],
            [-0.0238, 0.0238, 0.0406, 0.0238, -0.0200, -0.0444, -0.3723, -0.0200, 0.0200, -0.1132, 0.0824, 0.0471, 0.0000, 0.0824, 0.4367, 1.0000, -0.0763, -0.2699, -0.2171, -0.0763, -0.2171, -0.1063, -0.1063, -0.1063, 0.1063, 0.2171, -0.1212, -0.0727, -0.1212, -0.2399, -0.1939, -0.2399, -0.4338, 0.0000, -0.4338, -0.5662, -0.4082, -0.5918, -0.4082, -0.1132, -0.4530],
            [-0.0069, 0.0069, 0.0117, 0.0069, -0.0058, -0.0128, -0.1076, -0.0058, 0.0058, -0.1036, 0.2492, 0.1424, 0.0000, 0.2492, 0.1262, 0.0000, 0.0078, 0.0277, 0.0907, 0.0078, 0.0907, 0.0619, 0.0619, 0.0619, -0.0619, -0.0907, 0.3402, 0.2041, 0.3402, -0.0264, -0.4557, -0.0264, -0.4821, 0.0000, -0.4821, -0.5179, -0.4082, -0.5918, -0.4082, -0.1036, -0.4143],
            [-0.0147, 0.0147, 0.0250, 0.0147, -0.0123, -0.0273, -0.2293, -0.0123, 0.0123, -0.0982, 0.1413, 0.0807, 0.0000, 0.1413, 0.2689, 0.0000, 0.0751, 0.2659, -0.0721, 0.0751, -0.0721, -0.1086, -0.1086, -0.1086, 0.1086, 0.0721, 0.0258, 0.0155, 0.0258, 0.4496, 0.0413, -0.5504, -0.5091, 0.0000, -0.5091, -0.4909, -0.4082, -0.5918, -0.4082, -0.0982, -0.3927],
            [0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, -0.4082, -0.5918, -0.4082, 0.0000, 0.0000]])

    J = np.array([[0.1287, 0.1288, 0.1132, 0.1036, 0.0982, 0.0000, -0.1288, -0.1281, -0.1280, -0.1297, 0.7355, -0.1095, -0.1132, -0.1105, -0.1083, -0.1117, -0.1102, -0.1087, -0.1090, -0.1091, -0.1049, -0.0982, -0.0845, -0.0329, 0.0000, 0.0000],
                  [0.0279, 0.0273, 0.0763, -0.0078, -0.0751, 0.0000, -0.0273, -0.0297, -0.0301, -0.0247, -0.0236, 0.0012, -0.0763, 0.4634, 0.1093, -0.0433, -0.0120, 0.0716, 0.0493, 0.0373, 0.0064, 0.0751, 0.0290, 0.0113, 0.0000, 0.0000],
                  [-0.0323, -0.0301, -0.2171, 0.0907, -0.0721, 0.0000, 0.0301, 0.0393, 0.0408, 0.0202, 0.0174, -0.1124, 0.2171, 0.1742, 0.1413, 0.5024, 0.7735, 0.0527, 0.0004, -0.0278, -0.0955, 0.0721, -0.0213, -0.0083, 0.0000, 0.0000]])

    J_max = np.array([10, 8, 10, 10, 8, 10])

    P = matrix(np.diag(np.append(b_real, d_real)))
    q = matrix(np.append(a_declare, c_real))
    G = matrix(np.vstack((J, -J, np.diag(-np.ones(26)), np.diag(np.ones(26)))))
    h = matrix(np.hstack((J_max, p_min, q_min, p_max, q_max)))
    A = matrix(np.hstack((-np.ones(6), np.ones(20)))).T
    b = matrix(0.0)

    sv = solvers.qp(P, q, G, h, A, b)

    miu1, miu2 = np.zeros((41, 1)), np.zeros((41, 1))
    miu1[9],  miu1[16], miu1[25] = sv['z'][0:3]
    miu2[9],  miu2[16], miu2[25] = sv['z'][3:6]

    nodal_price_g = (np.ones((6, 1)) * sv['y'][0] + np.dot(J_g, miu1 - miu2)).squeeze()

    mc_amount = np.array(sv['x'][:6]).squeeze()

    cost_real = 0.5 * b_real * mc_amount ** 2 + a_real * mc_amount
    cost_declare = mc_amount * np.transpose(nodal_price_g)
    profit = cost_declare - cost_real

    return nodal_price_g, profit


if __name__ == '__main__':

    alpha = np.array([21.388, 23.807, 34.317, 27.235, 33.609, 24.848])
    print(market_clearing(alpha))
